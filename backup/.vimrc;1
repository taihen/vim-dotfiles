" Start with loading extensions with pathogen
call pathogen#runtime_append_all_bundles()

" Colzoorscheme and GUI nice-to-have {{{

" Some defaults
let g:solarized_termcolors=256    "default value is 16
let g:solarized_contrast="high"    "default value is normal
let g:solarized_visibility="high"    "default value is normal
let g:solarized_diffmode="high"    "default value is normal
syntax enable

" Solarized defaults, can be changed
" let g:solarized_termtrans=0
" let g:solarized_degrade=0
" let g:solarized_bold=1
" let g:solarized_underline=1
" let g:solarized_italic=1
" let g:solarized_hitrail=0
" let g:solarized_menu=1

" I like to have a different background in GUI and terminal modes, so I can
" use the following if-then

if has('gui_running')
    set background=light
    set t_Co=256
    let g:solarized_termcolors=256
    highlight SpellBad term=underline gui=undercurl guisp=Orange
else
    set background=dark
    set t_Co=16
    let g:solarized_termcolors=16
    let g:CSApprox_loaded=1
endif

" Two color schemes that I'm using, ir_black if an old one, solarized is
colorscheme solarized

" Toggle dark/light solarized
call togglebg#map("<F5>")

" Default font
set guifont=Inconsolata:h14"

"" }}}

" urgency on slow load
au * BufRead norm \

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
\ | wincmd p | diffthis
endif

if has("autocmd")
  autocmd FileType html,css,ruby setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab
  autocmd FileType python setlocal ai ts=4 sts=4 et sw=4
  autocmd BufNewFile,BufRead *.rss setfiletype xml
endif

" Custom commands and functions
" Show syntax highlighting groups for word under cursor
" Tip: http://stackoverflow.com/questions/1467438/find-out-to-which-highlight-group-a-particular-keyword-symbol-belongs-in-vim
nmap <C-S-P> :call <SID>SynStack()<CR>
function! <SID>SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" Set tabstop, softtabstop and shiftwidth to the same value
" From http://vimcasts.org/episodes/tabs-and-spaces/
command! -nargs=* Stab call Stab()
function! Stab()
  let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
  if l:tabstop > 0
    let &l:sts = l:tabstop
    let &l:ts = l:tabstop
    let &l:sw = l:tabstop
  endif
  call SummarizeTabs()
endfunction

function! SummarizeTabs()
  try
    echohl ModeMsg
    echon ' tabstop='.&l:ts
    echon ' shiftwidth='.&l:sw
    echon ' softtabstop='.&l:sts
    if &l:et
      echon ' expandtab'
    else
      echon ' noexpandtab'
    end
  finally
    echohl None
  endtry
endfunction




imap <F6>  # Last change: <C-R>=strftime("%d/%m/%Y %H:%M:%S")<CR>
vmap <F4> gq
nmap <F9> :set paste!<BAR>:set paste?<CR>
map <F10> <Esc>:setlocal spell spelllang=en_us<CR>
map <F11> <Esc>:setlocal nospell<CR>
filetype plugin on
filetype indent on
filetype on
set grepprg=grep\ -nH\ $*
"au WinLeave * set nocursorline nocursorcolumn
"au WinEnter * set cursorline cursorcolumn
"set cursorline cursorcolumn
set guioptions=aegimrLt
set history=1000
set number

" no compatibility with vi for some cool stuff
set nocompatible

" This shows what you are typing as a command.  I love this!
set showcmd

" Folding Stuffs
set foldmethod=marker

set noexpandtab
set spelllang=en_gb
set ignorecase
set autowrite
set backup
set backupdir=~/.vim/backup
set directory=~/.vim/temp

" Kill signature
map <F8> <ESC>:/^[ ]*> -- *$/;?^[ >][ >]*$?;.,/^[ ]*$/-1d<CR>

" Let's not notified about hidden buffers
set nohidden

" Shortcut to rapidly toggle `set list`
nmap <leader>l :set list!<CR>

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,trail:◇,extends:»,precedes:«,eol:¬
"Invisible character colors highlight NonText guifg=#4a4a59 highlight SpecialKey guifg=#4a4a59

" highlight current line
set cursorline

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" auto change directory
set autochdir

set mousehide
set noerrorbells
set linespace=0
set report=0
set noicon
set ruler
set shell=bash
set showmode
set shortmess=at
set ttyscroll=0
set wrapmargin=1
set foldexpr=getline(v:lnum)[0]==\"\\t\"

" Search Settings {{{
set hlsearch
set incsearch
set showmatch
set ignorecase
set smartcase
set matchtime=5
map N Nzz
map n nzz
" }}}
"

" Tab Settings {{{
set autoindent
set expandtab
set shiftwidth=4
"set smartindent     " Screws up python indenting
set smarttab
set softtabstop=4
set tabstop=4
" }}}

" Tab navigation like firefox
nnoremap <silent> <C-Right> :tabnext<CR>
nnoremap <silent> <C-Left> :tabprevious<CR>
nnoremap <silent> <C-t> :tabnew<CR>

set statusline=%F%m%r%h%w\
            \ ft:%{&ft}\ \
            \ff:%{&ff}\ \
            \%{strftime(\"%a\ %d/%m/%Y\ \
            \%H:%M:%S\",getftime(expand(\"%:p\")))}%=\ \
            \buf:%n\ \
            \L:%04l\ C:%04v\ \
            \T:%04L\ HEX:%03.3B\ ASCII:%03.3b\ %P
set laststatus=2 " Always show statusline
"set statusline=%F%m%r%h%w[%L][%{&ff}]%y[%p%%][%04l,%04v]
 "              | | | | |  |   |      |  |     |    |
 "              | | | | |  |   |      |  |     |    + current
 "              | | | | |  |   |      |  |     |       column
 "              | | | | |  |   |      |  |     +-- current line
 "              | | | | |  |   |      |  +-- current % into file
 "              | | | | |  |   |      +-- current syntax in
 "              | | | | |  |   |          square brackets
 "              | | | | |  |   +-- current fileformat
 "              | | | | |  +-- number of lines
 "              | | | | +-- preview flag in square brackets
 "              | | | +-- help flag in square brackets
 "              | | +-- readonly flag in square brackets
 "              | +-- rodified flag in square brackets
 "              +-- full path to file in the buffer

" PyDiction configuration {{{
let g:pydiction_location = '/home/taihen/.vim/pydiction-1.2/complete-dict'
" Default menu height is 15
let g:pydiction_menu_height = 20
if has("autocmd")
    autocmd FileType python set complete+=k/home/taihen/.vim/pydiction-1.2/pydiction isk+=.,(
endif

set makeprg=pep8\ %
" }}}

" nie pozwala na modyfikowanie plikow tylko do odczytu
au BufReadPost * :call CheckReadonly()
function! CheckReadonly()
	if version >= 600
	    if &readonly
	        setlocal nomodifiable
	    endif
	endif
endfunction

" ident dla notatek
if has("autocmd")
    autocmd BufEnter,BufNew *.note set smartindent foldmethod=indent expandtab tw=0 ts=4 sw=4 spell
endif

" Source the vimrc file after saving it
if has("autocmd")
  autocmd bufwritepost .vimrc source $MYVIMRC
endif

let mapleader = ","
nmap <leader>v :tabedit $MYVIMRC<CR>

" Remove any trailing whitespace that is in the file
autocmd BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif

" Restore cursor position to where it was before
augroup JumpCursorOnEdit
   au!
   autocmd BufReadPost *
            \ if expand("<afile>:p:h") !=? $TEMP |
            \   if line("'\"") > 1 && line("'\"") <= line("$") |
            \     let JumpCursorOnEdit_foo = line("'\"") |
            \     let b:doopenfold = 1 |
            \     if (foldlevel(JumpCursorOnEdit_foo) > foldlevel(JumpCursorOnEdit_foo - 1)) |
            \        let JumpCursorOnEdit_foo = JumpCursorOnEdit_foo - 1 |
            \        let b:doopenfold = 2 |
            \     endif |
            \     exe JumpCursorOnEdit_foo |
            \   endif |
            \ endif
   " Need to postpone using "zv" until after reading the modelines.
   autocmd BufWinEnter *
            \ if exists("b:doopenfold") |
            \   exe "normal zv" |
            \   if(b:doopenfold > 1) |
            \       exe  "+".1 |
            \   endif |
            \   unlet b:doopenfold |
            \ endif
augroup END

" Fix email paragraphs
nnoremap <leader>par :%s/^>$//<CR>

" Par formating
:set formatprg=par\ -w60
:map <A-q> {v}!par -jw60<CR>
:vmap <A-q> !par -jw60<CR>

" turn on wild menu :e <Tab>
set wildmenu
" set wildmenu to list choice
set wildmode=longest:full

" hasrocket made simple
imap <C-l> <Space>=><Space>


" load dictionary files for complete suggestion with Ctrl-n
set complete+=k
autocmd FileType * exec('set dictionary+=~/.vim/spell/' . &filetype)

    " insert change log in files
    fun! InsertChangeLog()
    let l:flag=0
    for i in range(1,5)
        if getline(i) !~ '.*Last Change.*'
            let l:flag = l:flag + 1
        endif
    endfor
    if l:flag >= 5
        normal(1G)
        call append(0, "File: <+Description+>")
        call append(1, "Created: " . strftime("%a %d/%b/%Y hs %H:%M"))
        call append(2, "Last Change: " . strftime("%a %d/%b/%Y hs %H:%M"))
        call append(3, "author: <+your name+>")
        call append(4, "site: <+site+>")
        call append(5, "twitter: <+your twitter here+>")
        normal gg
    endif
endfun
map <special> <F4> <esc>:call InsertChangeLog()<cr>

" update changefile log
" http://tech.groups.yahoo.com/group/vim/message/51005
fun! LastChange()
    let _s=@/
    let l = line(".")
    let c = col(".")
    if line("$") >= 5
        1,5s/\s*Last Change:\s*\zs.*/\="" . strftime("%Y %b %d %X")/ge
    endif
    let @/=_s
    call cursor(l, c)
endfun
autocmd BufWritePre * keepjumps call LastChange()

    function! JumpToNextPlaceholder()
    let old_query = getreg('/')
    echo search("<+.\\++>")
    exec "norm! c/+>/e\<CR>"
    call setreg('/', old_query)
endfunction
autocmd BufNewFile * :call LoadFileTemplate()
nnoremap <special> <leader>j :call JumpToNextPlaceholder()<CR>a
inoremap <special> <leader>j <ESC>:call JumpToNextPlaceholder()<CR>a

imap ^[OA <ESC>ki
imap ^[OB <ESC>ji
imap ^[OC <ESC>li
imap ^[OD <ESC>hi

" replace lenght of current line with a new line of single
let @h = "yypVr"
